"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZBWorker = void 0;
const ZBWorkerBase_1 = require("../lib/ZBWorkerBase");
class ZBWorker extends ZBWorkerBase_1.ZBWorkerBase {
    constructor(config) {
        super(config);
    }
    handleJobs(jobs) {
        // Call task handler for each new job
        jobs.forEach(async (job) => this.handleJob(job));
    }
    async handleJob(job) {
        try {
            /**
             * complete.success(variables?: object) and complete.failure(errorMessage: string, retries?: number)
             *
             * To halt execution of the business process and raise an incident in Operate, call
             * complete.failure(errorMessage, 0)
             */
            const workerCallback = this.makeCompleteHandlers(job);
            await this.taskHandler({
                ...job,
                cancelWorkflow: workerCallback.cancelWorkflow,
                complete: workerCallback.complete,
                fail: workerCallback.fail,
                error: workerCallback.error,
                forward: workerCallback.forward,
            }, this);
        }
        catch (e) {
            this.logger.logError(`Caught an unhandled exception in a task handler for process instance ${job.processInstanceKey}:`);
            this.logger.logDebug(job);
            // If the exception has a details field, log it
            // This is the case for exceptions thrown when the job is not found. The details field contains an explanation.
            const hasDetails = (e) => !!e.details;
            if (hasDetails(e)) {
                this.logger.logError(e.details);
            }
            else {
                this.logger.logError(e.message);
            }
            if (this.cancelWorkflowOnException) {
                const { processInstanceKey } = job;
                this.logger.logDebug(`Cancelling process instance ${processInstanceKey}`);
                try {
                    await this.zbClient.cancelProcessInstance(processInstanceKey);
                }
                finally {
                    this.drainOne();
                }
            }
            else {
                const message = e.message;
                // This is *most probably* an error thrown because the job was not found when job.complete() or job.fail() was called.
                // It could also happen in some cases where the handler does another operation that returns an error with the same code.
                if (message.includes('5 NOT_FOUND') &&
                    message.includes(job.key) &&
                    (message.includes('COMPLETE') || message.includes('FAIL'))) {
                    this.logger.logDebug(`Job ${job.key} was already completed or failed, or the process instance was cancelled. Ignoring.`);
                    this.drainOne();
                    return;
                }
                this.logger.logInfo(`Failing job ${job.key} due to unhandled exception`);
                const retries = job.retries - 1;
                try {
                    this.zbClient
                        .failJob({
                        errorMessage: `Unhandled exception in task handler ${e}`,
                        jobKey: job.key,
                        retries,
                        retryBackOff: 0,
                    })
                        .catch((e) => {
                        console.error('Any error was thrown while failing the job after an unhandled exception in the task handler');
                        console.error(e.message);
                    });
                }
                catch (e) {
                    this.logger.logDebug(e);
                }
                finally {
                    this.drainOne();
                    if (retries > 0) {
                        this.logger.logDebug(`The Zeebe engine will handle the retry. Retries left: ${retries}`);
                    }
                    else {
                        this.logger.logDebug('No retries left for this task');
                    }
                }
            }
        }
    }
}
exports.ZBWorker = ZBWorker;
//# sourceMappingURL=ZBWorker.js.map