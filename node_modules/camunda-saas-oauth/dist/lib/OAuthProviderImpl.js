"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuthProviderImpl = void 0;
const fs = __importStar(require("fs"));
const got_1 = __importDefault(require("got"));
const os = __importStar(require("os"));
const homedir = os.homedir();
const BACKOFF_TOKEN_ENDPOINT_FAILURE = 1000;
class OAuthProviderImpl {
    constructor({ 
    /** OAuth Endpoint URL */
    authServerUrl, 
    /** OAuth Audience */
    audience, clientId, clientSecret, userAgentString }) {
        this.tokenCache = {};
        this.failed = false;
        this.failureCount = 0;
        this.getCacheKey = (audience) => `${this.clientId}-${audience}`;
        this.getCachedTokenFileName = (clientId, audience) => `${this.cacheDir}/oauth-token-${clientId}-${audience}.json`;
        this.authServerUrl = authServerUrl;
        this.zeebeAudience = audience;
        this.audience = audience;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.useFileCache = process.env.CAMUNDA_TOKEN_CACHE !== "memory-only";
        this.cacheDir = OAuthProviderImpl.getTokenCacheDirFromEnv();
        this.userAgentString = userAgentString; // e.g.: `zeebe-client-nodejs/${pkg.version} ${CUSTOM_AGENT_STRING}`
        if (this.useFileCache) {
            try {
                if (!fs.existsSync(this.cacheDir)) {
                    fs.mkdirSync(this.cacheDir);
                }
                fs.accessSync(this.cacheDir, fs.constants.W_OK);
            }
            catch (e) {
                throw new Error(`FATAL: Cannot write to OAuth cache dir ${this.cacheDir}\n` +
                    'If you are running on AWS Lambda, set the HOME environment variable of your lambda function to /tmp');
            }
        }
    }
    close() {
        if (this.expiryTimer) {
            clearTimeout(this.expiryTimer);
        }
    }
    getToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getCacheKey(audience);
            if (this.tokenCache[key]) {
                return this.tokenCache[key].access_token;
            }
            if (this.useFileCache) {
                const cachedToken = this.fromFileCache(this.clientId, audience);
                if (cachedToken) {
                    return cachedToken.access_token;
                }
            }
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.debouncedTokenRequest(audience)
                        .then(res => {
                        this.failed = false;
                        this.failureCount = 0;
                        resolve(res);
                    })
                        .catch(e => {
                        this.failureCount++;
                        this.failed = true;
                        reject(e);
                    });
                }, this.failed ? BACKOFF_TOKEN_ENDPOINT_FAILURE * this.failureCount : 1);
            });
        });
    }
    debouncedTokenRequest(audience) {
        const form = {
            audience: this.getAudience(audience),
            client_id: this.clientId,
            client_secret: this.clientSecret,
            grant_type: 'client_credentials',
        };
        return got_1.default
            .post(this.authServerUrl, {
            form,
            headers: {
                'content-type': 'application/x-www-form-urlencoded',
                'user-agent': this.userAgentString,
            },
        })
            .then(res => this.safeJSONParse(res.body)
            .then(t => {
            const token = Object.assign(Object.assign({}, t), { audience });
            if (this.useFileCache) {
                this.toFileCache(token, audience);
            }
            const key = this.getCacheKey(audience);
            const d = new Date();
            token.expiry = d.setSeconds(d.getSeconds()) + (token.expires_in * 1000);
            this.tokenCache[key] = token;
            this.startExpiryTimer(token, audience);
            return token.access_token;
        }));
    }
    safeJSONParse(thing) {
        return new Promise((resolve, reject) => {
            try {
                resolve(JSON.parse(thing));
            }
            catch (e) {
                reject(e);
            }
        });
    }
    fromFileCache(clientId, audience) {
        let token;
        const tokenCachedInFile = fs.existsSync(this.getCachedTokenFileName(clientId, audience));
        if (!tokenCachedInFile) {
            return null;
        }
        try {
            token = JSON.parse(fs.readFileSync(this.getCachedTokenFileName(clientId, audience), 'utf8'));
            if (this.isExpired(token)) {
                return null;
            }
            this.startExpiryTimer(token, audience);
            return token;
        }
        catch (_) {
            return null;
        }
    }
    toFileCache(token, audience) {
        const d = new Date();
        const file = this.getCachedTokenFileName(this.clientId, audience);
        fs.writeFile(file, JSON.stringify(Object.assign(Object.assign({}, token), { expiry: d.setSeconds(d.getSeconds() + token.expires_in) })), e => {
            if (!e) {
                return;
            }
            // tslint:disable-next-line
            console.error('Error writing OAuth token to file' + file);
            // tslint:disable-next-line
            console.error(e);
        });
    }
    isExpired(token) {
        const d = new Date();
        return token.expiry <= d.setSeconds(d.getSeconds());
    }
    startExpiryTimer(token, audience) {
        const d = new Date();
        const current = d.setSeconds(d.getSeconds());
        const validityPeriod = token.expiry - current;
        const minimumCacheLifetime = 0; // Minimum cache lifetime in milliseconds
        const renewTokenAfterMs = Math.max(validityPeriod - 1000, minimumCacheLifetime); // 1s before expiry
        const cacheKey = this.getCacheKey(audience);
        if (validityPeriod <= 0) {
            delete this.tokenCache[cacheKey];
            return;
        }
        this.expiryTimer = setTimeout(() => {
            const filename = this.getCachedTokenFileName(this.clientId, audience);
            delete this.tokenCache[cacheKey];
            if (this.useFileCache && fs.existsSync(filename)) {
                fs.unlinkSync(filename);
            }
        }, renewTokenAfterMs);
    }
    getAudience(audience) {
        const audiences = {
            OPERATE: 'operate.camunda.io',
            ZEEBE: this.zeebeAudience,
            OPTIMIZE: 'optimize.camunda.io',
            TASKLIST: 'tasklist.camunda.io',
            CONSOLE: this.audience || 'api.cloud.camunda.io'
        };
        return audiences[audience];
    }
}
exports.OAuthProviderImpl = OAuthProviderImpl;
OAuthProviderImpl.defaultTokenCache = `${homedir}/.camunda`;
OAuthProviderImpl.getTokenCacheDirFromEnv = () => process.env.CAMUNDA_TOKEN_CACHE_DIR || OAuthProviderImpl.defaultTokenCache;
